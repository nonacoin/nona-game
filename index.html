<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dice Party - Online Multiplayer</title>
<style>
    /* ======================================= */
    /* üé® GAME STYLES - MODERN DESIGN           */
    /* ======================================= */
    
    /* Main body */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
        color: #fff;
        padding: 12px;
        box-sizing: border-box;
        overflow-x: hidden;
    }

    /* Background particles */
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
            radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.05) 0%, transparent 20%),
            radial-gradient(circle at 80% 70%, rgba(0, 255, 128, 0.05) 0%, transparent 20%);
        z-index: -1;
    }

    /* Game container */
    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        max-width: 720px;
        width: 100%;
    }

    /* ======================================= */
    /* üéÆ PLAYERS & TIMER - NEW DESIGN          */
    /* ======================================= */
    
    /* Top wrapper */
    #top-wrapper {
        display: flex;
        gap: 5px;
        justify-content: space-between;
        width: 100%;
        padding: 0 5px;
    }

    /* Each player box */
    .player-box {
        width: 45%;
        min-width: 130px;
        max-width: 150px;
        background: rgba(30, 30, 46, 0.9);
        padding: 8px 10px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 4px;
        transition: all 0.3s ease;
    }

    /* Active player */
    .player-box.active-player {
        transform: scale(1.03);
        animation: glowEffect 2s infinite alternate;
    }

    /* Player 1 - Golden */
    .player-box.player1 {
        border: 2px solid #FFD700;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }
    .player-box.player1.active-player {
        box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
    }

    /* Player 2 - Green */
    .player-box.player2 {
        border: 2px solid #00FF7F;
        box-shadow: 0 0 15px rgba(0, 255, 127, 0.3);
    }
    .player-box.player2.active-player {
        box-shadow: 0 0 25px rgba(0, 255, 127, 0.6);
    }

    /* Glow effect for active player */
    @keyframes glowEffect {
        0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.7); }
    }

    /* Inactive player */
    .player-box.inactive {
        opacity: 0.6;
        filter: grayscale(40%);
        transform: scale(0.98);
    }

    /* Player title */
    .player-title {
        font-size: 16px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 7px;
    }

    /* Player title colors */
    .player1 .player-title {
        color: #FFD700;
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
    }
    .player2 .player-title {
        color: #00FF7F;
        text-shadow: 0 0 8px rgba(0, 255, 127, 0.5);
    }

    /* Player icons */
    .player1 .player-title::before {
        content: 'üëë';
    }
    .player2 .player-title::before {
        content: '‚öîÔ∏è';
    }

    /* ======================================= */
    /* ‚è±Ô∏è TIMER SECTION                         */
    /* ======================================= */
    
    /* Timer display */
    .player-timer {
        font-size: 18px;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 8px;
        color: #000;
        min-width: 42px;
        text-align: center;
        font-family: 'Courier New', monospace;
        border: 2px solid rgba(255, 255, 255, 0.3);
        animation: pulse 1s infinite;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Pulse animation */
    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
    }

    /* Player 1 timer - Yellow */
    .player1 .player-timer {
        background: linear-gradient(135deg, #FFD700, #FFA500);
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }

    /* Player 2 timer - Green */
    .player2 .player-timer {
        background: linear-gradient(135deg, #00FF7F, #00CC66);
        box-shadow: 0 4px 15px rgba(0, 255, 127, 0.4);
    }

    /* Active timer */
    .player-timer.active {
        animation: heartbeat 1s infinite;
        font-weight: 900;
    }

    /* Heartbeat animation */
    @keyframes heartbeat {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
    }

    /* Warning mode (last 10 seconds) */
    .player-timer.warning {
        background: linear-gradient(135deg, #FF3333, #CC0000) !important;
        color: white !important;
        font-size: 18px;
        animation: warningPulse 0.5s infinite alternate;
        box-shadow: 0 0 25px rgba(255, 0, 0, 0.7) !important;
    }

    /* Warning pulse animation */
    @keyframes warningPulse {
        0% { transform: scale(1); }
        100% { transform: scale(1.15); }
    }

    /* ======================================= */
    /* üìä SCORE BOARD - NEW DESIGN             */
    /* ======================================= */
    
    /* Score board container */
    #score-board {
        width: 460px;
        background: rgba(30, 30, 46, 0.9);
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 9px 21px rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.08);
    }

    /* Score header */
    .score-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    }

    /* Column titles */
    .score-column-title {
        font-size: 18px;
        font-weight: bold;
        padding: 6px 1px;
        border-radius: 1px;
        flex: 1;
        text-align: center;
        margin: 0 2px;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Player 1 column title */
    .score-column-title.player1 {
        background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.1));
        color: #FFD700;
        border: 1px solid rgba(255, 215, 0, 0.3);
    }

    /* Player 2 column title */
    .score-column-title.player2 {
        background: linear-gradient(135deg, rgba(0, 255, 127, 0.2), rgba(0, 204, 102, 0.1));
        color: #00FF7F;
        border: 1px solid rgba(0, 255, 127, 0.3);
    }

    /* Dice column title */
    .score-column-title.dice {
        background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.1));
        color: #8A2BE2;
        border: 1px solid rgba(138, 43, 226, 0.3);
    }

    /* Each score row */
    .score-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 0;
        margin-bottom: 6px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
        transition: all 0.3s ease;
        cursor: pointer;
        position: relative;
    }

    /* Hover effect on row */
    .score-row:hover {
        background: linear-gradient(90deg, 
            rgba(138, 43, 226, 0.1), 
            rgba(75, 0, 130, 0.05), 
            rgba(138, 43, 226, 0.1)
        );
        transform: translateY(-2px);
    }

    /* Selected row */
    .score-row.selected {
        background: linear-gradient(90deg, 
            rgba(255, 215, 0, 0.15), 
            rgba(255, 165, 0, 0.1), 
            rgba(255, 215, 0, 0.15)
        );
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        border: 1px solid rgba(255, 215, 0, 0.4);
    }

    /* Dice column (middle) */
    .score-column.dice {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* Score column */
    .score-column {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 5px;
    }

    /* Mini dice image */
    .mini-dice {
        width: 40px;
        height: 40px;
        border-radius: 6px;
        transition: all 0.3s ease;
        cursor: pointer;
        filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.3));
    }

    /* Hover effect on dice */
    .score-row:hover .mini-dice {
        transform: scale(1.15) rotate(10deg);
        filter: drop-shadow(0 5px 10px rgba(255, 215, 0, 0.5));
    }

    /* Value box (score display) */
    .value-box {
        width: 60px;
        padding: 6px 8px;
        font-size: 18px;
        border-radius: 8px;
        border: none;
        outline: none;
        text-align: center;
        background: rgba(40, 40, 60, 0.9);
        color: #fff;
        direction: ltr;
        font-weight: bold;
        font-family: 'Courier New', monospace;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
    }

    /* Confirmed score by Player 1 */
    .value-box.confirmed.player1 {
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #000;
        border: 1px solid rgba(255, 215, 0, 0.6);
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
        font-weight: 900;
    }

    /* Confirmed score by Player 2 */
    .value-box.confirmed.player2 {
        background: linear-gradient(135deg, #00FF7F, #00CC66);
        color: #000;
        border: 1px solid rgba(0, 255, 127, 0.6);
        box-shadow: 0 4px 12px rgba(0, 255, 127, 0.4);
        font-weight: 900;
    }

    /* Locked box (unchangeable) */
    .value-box.locked {
        opacity: 0.5;
        background: rgba(30, 30, 30, 0.8);
        color: #888;
    }

    /* ======================================= */
    /* üé≤ MAIN GAME AREA (DICE & BUTTONS)      */
    /* ======================================= */
    
    /* Main game box */
    #main-box {
        background: rgba(30, 30, 46, 0.9);
        padding: 15px;
        border-radius: 12px;
        width: 450px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* 3D dice container */
    #dice-container {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 15px 0;
        width: 100%;
        min-height: 54px;
    }

    /* Each dice scene */
    .scene {
        perspective: 600px;
        width: 51px;
        height: 51px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        padding: 2px;
    }

    /* Locked dice */
    .scene.locked {
        border: 2px solid rgba(255, 215, 0, 0.8);
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
    }

    /* Lock icon on dice */
    .scene.locked::before {
        content: 'üîí';
        position: absolute;
        top: -9px;
        right: -9px;
        font-size: 14px;
        z-index: 100;
        filter: drop-shadow(0 0 5px gold);
    }

    /* 3D cube */
    .cube {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 1s cubic-bezier(.2,.9,.3,1);
        transform: rotateX(-20deg) rotateY(20deg);
    }

    /* Each face of dice */
    .face {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        background: linear-gradient(145deg, #2a0845, #1a0a3e);
        backface-visibility: hidden;
        overflow: hidden;
        border: 2px solid rgba(255, 255, 255, 0.3);
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2);
    }

    /* Dice pips */
    .pip {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        position: relative;
        z-index: 2;
        box-shadow: 0 0 6px currentColor;
    }

    /* Pip colors for each face */
    .face.f1 .pip { background:#ff0033 !important; color:#ff0033 }
    .face.f2 .pip { background:#ffee55 !important; color:#ffee55 }
    .face.f3 .pip { background:#4ecbff !important; color:#4ecbff }
    .face.f4 .pip { background:#83ff4e !important; color:#83ff4e }
    .face.f5 .pip { background:#ff4ebd !important; color:#ff4ebd }
    .face.f6 .pip { background:#4efbff !important; color:#4efbff }

    /* 3x3 grid for pip arrangement */
    .grid3 {
        width: 80%;
        height: 80%;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
        gap: 6%;
        align-items: center;
        justify-items: center;
    }

    /* Face positions in 3D space */
    .f1 { transform: rotateX(90deg) translateZ(25.5px); }
    .f2 { transform: rotateY(90deg) translateZ(25.5px); }
    .f3 { transform: rotateY(0deg) translateZ(25.5px); }
    .f4 { transform: rotateY(180deg) translateZ(25.5px); }
    .f5 { transform: rotateY(-90deg) translateZ(25.5px); }
    .f6 { transform: rotateX(-90deg) translateZ(25.5px); }

    /* ======================================= */
    /* üéÆ GAME BUTTONS                         */
    /* ======================================= */
    
    /* Button row */
    #button-row {
        display: flex;
        gap: 18px;
        margin-top: 15px;
        width: 100%;
        justify-content: center;
    }

    /* Game buttons */
    .game-btn {
        padding: 10px 30px;
        font-size: 20px;
        cursor: pointer;
        border: none;
        border-radius: 10px;
        font-weight: bold;
        transition: all 0.3s ease;
        min-width: 90px;
        text-align: center;
        position: relative;
        overflow: hidden;
    }

    /* Shine effect for buttons */
    .game-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.7s;
    }

    .game-btn:hover::before {
        left: 100%;
    }

    /* Roll button */
    #roll-btn {
        background: linear-gradient(135deg, #FF0080, #FF3399);
        color: white;
        box-shadow: 0 6px 18px rgba(255, 0, 128, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.2);
    }

    /* Play button */
    #play-btn {
        background: linear-gradient(135deg, #6600cc, #9933ff);
        color: white;
        box-shadow: 0 6px 18px rgba(102, 0, 204, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.2);
    }

    /* Button hover effect */
    .game-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    /* Disabled button */
    .game-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
        background: linear-gradient(135deg, #666, #444);
    }

    /* ======================================= */
    /* üèÜ FINAL RESULTS                        */
    /* ======================================= */
    
    /* Results screen */
    .results-screen {
        background: rgba(20, 20, 40, 0.95);
        padding: 24px;
        border-radius: 15px;
        width: 480px;
        box-shadow: 0 15px 36px rgba(0, 0, 0, 0.5);
        text-align: center;
        border: 2px solid rgba(138, 43, 226, 0.4);
        display: none;
        margin-top: 15px;
        backdrop-filter: blur(10px);
    }

    /* Results title */
    .results-title {
        font-size: 22px;
        font-weight: bold;
        margin-bottom: 18px;
        color: #ffcc00;
        text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
    }

    /* ======================================= */
    /* üì± RESPONSIVE DESIGN (MOBILE & TABLET)  */
    /* ======================================= */
    
    /* Tablet and large mobile */
    @media (max-width: 768px) {
        body {
            padding: 8px;
        }
        
        #top-wrapper {
            flex-direction: row;
            flex-wrap: nowrap;
            justify-content: space-between;
            gap: 5px;
            width: 100%;
        }
        
        .player-box {
            width: 48%;
            min-width: 140px;
            padding: 6px 8px;
            flex: 1;
        }
        
        .player-title {
            font-size: 14px;
        }
        
        .player-timer {
            font-size: 12px;
            padding: 3px 6px;
            min-width: 28px;
        }
        
        #score-board {
            width: 100%;
            max-width: 100%;
            padding: 10px;
        }
        
        .score-header {
            flex-direction: row;
            gap: 3px;
        }
        
        .score-column-title {
            margin: 0 1px;
            font-size: 13px;
            padding: 5px 9px;
        }
        
        .value-box {
            width: 75px;
            padding: 8px 10px;
            font-size: 16px;
        }
        
        .mini-dice {
            width: 40px;
            height: 40px;
        }

        .pip {
            width: 7px;
            height: 7px;
        }
        
        #main-box {
            width: 100%;
            max-width: 100%;
            padding: 10px;
        }
        
        #dice-container {
            gap: 8px;
        }
        
        .scene {
            width: 50px;
            height: 50px;
        }
        
        .game-btn {
            padding: 14px 28px;
            font-size: 18px;
            min-width: 120px;
            width: auto;
        }
        
        .results-screen {
            width: 100%;
            padding: 15px;
        }
    }

    /* Additional animations */
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
        20%, 40%, 60%, 80% { transform: translateX(5px); }
    }

    @keyframes scorePop {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }

    /* Turn indicator */
    .turn-indicator {
        position: absolute;
        top: -10px;
        right: 50%;
        transform: translateX(50%);
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #000;
        padding: 3px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: bold;
        animation: pulse 1s infinite;
        z-index: 10;
        display: none;
    }

    .player-box.active-player .turn-indicator {
        display: block;
    }

    /* Turn lost message */
    .turn-lost-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 0, 0, 0.9);
        color: white;
        padding: 20px 30px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: bold;
        z-index: 1000;
        animation: fadeInOut 2s forwards;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
        text-align: center;
    }

    @keyframes fadeInOut {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
</style>
</head>
<body>

<!-- ======================================= -->
<!-- üèóÔ∏è GAME HTML STRUCTURE                  -->
<!-- ======================================= -->

<div id="game-container">
    <!-- Top section: Player info -->
    <div id="top-wrapper">
        <!-- Player 1 -->
        <div id="playerBox1" class="player-box player1 active-player">
            <div class="turn-indicator">Your Turn</div>
            <div class="player-title">Player 1</div>
            <div id="player1Timer" class="player-timer active">30</div>
        </div>
        <!-- Player 2 -->
        <div id="playerBox2" class="player-box player2 inactive">
            <div class="turn-indicator">Your Turn</div>
            <div class="player-title">Player 2</div>
            <div id="player2Timer" class="player-timer">30</div>
        </div>
    </div>

    <!-- Score board with new design -->
    <div id="score-board">
        <div class="score-header">
            <div class="score-column-title player1">Player 1</div>
            <div class="score-column-title dice">Dice</div>
            <div class="score-column-title player2">Player 2</div>
        </div>
        <!-- Rows will be created by JavaScript -->
    </div>

    <!-- Main game area -->
    <div id="main-box">
        <!-- 3D Dice -->
        <div id="dice-container"></div>

        <!-- Game buttons -->
        <div id="button-row">
            <button id="roll-btn" class="game-btn">Roll Dice</button>
            <button id="play-btn" class="game-btn" disabled>Confirm</button>
        </div>
    </div>

    <!-- Results screen -->
    <div id="results-screen" class="results-screen">
        <div class="results-title">üèÜ Final Results</div>
        <div class="results-columns" id="resultsColumns"></div>
    </div>
</div>

<!-- ======================================= -->
<!-- üîä GAME SOUNDS                           -->
<!-- ======================================= -->

<audio id="diceSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/tasandakhtan.wav"></audio>
<audio id="lockSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/ghofl.wav"></audio>
<audio id="selectSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/ghofl.wav"></audio>
<audio id="confirmSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/sabt.wav"></audio>
<audio id="timeoutSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/sabt.wav"></audio>
<audio id="warningSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/ghofl.wav"></audio>
<audio id="tickSound" src="https://raw.githubusercontent.com/nonacoin/nona-game/main/sounds/ghofl.wav"></audio>

<script>
// ======================================= //
// üéØ MAIN GAME VARIABLES                   //
// ======================================= //

// Game sounds
const diceSound = document.getElementById('diceSound');
const lockSound = document.getElementById('lockSound');
const selectSound = document.getElementById('selectSound');
const confirmSound = document.getElementById('confirmSound');
const timeoutSound = document.getElementById('timeoutSound');
const warningSound = document.getElementById('warningSound');
const tickSound = document.getElementById('tickSound');

// Set sound volumes
[diceSound, lockSound, selectSound, confirmSound, timeoutSound, warningSound, tickSound].forEach(sound => {
    sound.volume = 0.7;
    sound.preload = 'auto';
});

// Supabase configuration - REPLACE WITH YOUR OWN
const SUPABASE_CONFIG = {
    URL: "https://xouwoemiyxnugontsles.supabase.co",
    ANON_KEY: "sb_publishable_MFoTbKuCDjhVCs1-xvKNag_UwhV0tF-",
    FUNCTIONS_URL: "https://xouwoemiyxnugontsles.supabase.co/functions/v1/create-game"
};

// Base URL for dice images
const baseURL = "https://raw.githubusercontent.com/nonacoin/main/main/Dice/";

// ======================================= //
// üé≤ DICE HELPER FUNCTIONS                 //
// ======================================= //

function rand1to6() { 
    return Math.floor(Math.random() * 6) + 1; 
}

const facePips = {
    1: [5], 2: [1,9], 3: [1,5,9], 4: [1,3,7,9], 5: [1,3,5,7,9], 6: [1,3,4,6,7,9]
};

const rotations = {
    1: {x: -90, y: 0}, 2: {x: 0, y: -90}, 3: {x: 0, y: 0},
    4: {x: 0, y: 180}, 5: {x: 0, y: 90}, 6: {x: 90, y: 0}
};

// ======================================= //
// üéÆ CURRENT GAME STATE                    //
// ======================================= //

let gameState = {
    currentPlayer: 1,
    rollCount: 0,
    maxRolls: 3,
    selectedCategory: null,
    confirmedCategories: {
        player1: Array(6).fill(null),
        player2: Array(6).fill(null)
    },
    gameFinished: false,
    specialBonuses: { player1: 0, player2: 0 },
    roomId: null,
    playerNames: { player1: "Player 1", player2: "Player 2" }
};

let gameStats = {
    player1: { totalScore: 0, gamesPlayed: 0, wins: 0, losses: 0, totalSpecialBonus: 0 },
    player2: { totalScore: 0, gamesPlayed: 0, wins: 0, losses: 0, totalSpecialBonus: 0 }
};

// ======================================= //
// ‚è±Ô∏è TIMER SYSTEM - UPDATED                //
// ======================================= //

let timerInterval = null;
let timeLeft = 30;
const TOTAL_TIME = 30;
let warningPlayed = false;
let isTimeUpProcessing = false;

function startTimer() {
    if (gameState.gameFinished) return;
    
    clearInterval(timerInterval);
    timeLeft = TOTAL_TIME;
    warningPlayed = false;
    updateTimerDisplay();
    
    timerInterval = setInterval(() => {
        if (gameState.gameFinished) { 
            clearInterval(timerInterval); 
            return; 
        }
        
        timeLeft--;
        updateTimerDisplay();
        
        // Heartbeat with each second
        pulseTimer();
        
        // Last 10 seconds
        if (timeLeft <= 10) {
            enableWarningMode();
            if (timeLeft <= 5 && !warningPlayed) {
                playWarningSound();
                warningPlayed = true;
            }
        }
        
        if (timeLeft <= 0 && !isTimeUpProcessing) {
            timeUp();
        }
    }, 1000);
}

function pulseTimer() {
    const timer = gameState.currentPlayer === 1 
        ? document.getElementById('player1Timer')
        : document.getElementById('player2Timer');
    
    timer.style.transform = 'scale(1.08)';
    setTimeout(() => {
        timer.style.transform = 'scale(1)';
    }, 300);
}

function enableWarningMode() {
    const timer = gameState.currentPlayer === 1 
        ? document.getElementById('player1Timer')
        : document.getElementById('player2Timer');
    
    timer.classList.add('warning');
    
    if (timeLeft <= 10) {
        tickSound.currentTime = 0;
        tickSound.play().catch(e => console.log("Sound error"));
    }
}

function playWarningSound() {
    warningSound.currentTime = 0;
    warningSound.play().catch(e => console.log("Sound error"));
}

function updateTimerDisplay() {
    const p1 = document.getElementById('player1Timer');
    const p2 = document.getElementById('player2Timer');
    
    if (gameState.currentPlayer === 1) {
        p1.textContent = timeLeft;
        p1.classList.add('active');
        p2.textContent = TOTAL_TIME;
        p2.classList.remove('active', 'warning');
        
        if (timeLeft <= 10) {
            p1.classList.add('warning');
        } else {
            p1.classList.remove('warning');
        }
    } else {
        p2.textContent = timeLeft;
        p2.classList.add('active');
        p1.textContent = TOTAL_TIME;
        p1.classList.remove('active', 'warning');
        
        if (timeLeft <= 10) {
            p2.classList.add('warning');
        } else {
            p2.classList.remove('warning');
        }
    }
}

function timeUp() {
    if (isTimeUpProcessing) return;
    isTimeUpProcessing = true;
    
    clearInterval(timerInterval);
    timeoutSound.currentTime = 0;
    timeoutSound.play();
    
    showTurnLostMessage();
    
    setTimeout(() => {
        if (gameState.selectedCategory) {
            autoConfirmSelection();
        } else {
            autoSelectAndConfirm();
        }
        isTimeUpProcessing = false;
    }, 1000);
}

function showTurnLostMessage() {
    const message = document.createElement('div');
    message.className = 'turn-lost-message';
    message.textContent = `‚è∞ Player ${gameState.currentPlayer} time's up! Turn lost.`;
    document.body.appendChild(message);
    
    setTimeout(() => {
        if (message.parentNode) {
            message.parentNode.removeChild(message);
        }
    }, 2000);
}

function autoConfirmSelection() {
    const { player, rowIndex } = gameState.selectedCategory;
    const playerKey = `player${player}`;
    const potentialScores = calculatePotentialScores();
    const score = potentialScores[rowIndex];
    gameState.confirmedCategories[playerKey][rowIndex] = score;
    
    confirmSound.currentTime = 0;
    confirmSound.play();
    
    showAutoConfirmMessage(player, rowIndex, score);
    
    setTimeout(() => {
        gameState.selectedCategory = null;
        checkSpecialBonus();
        checkGameCompletion();
    }, 500);
}

function showAutoConfirmMessage(player, rowIndex, score) {
    const message = document.createElement('div');
    message.className = 'turn-lost-message';
    message.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
    message.textContent = `‚úÖ Score ${score} confirmed for Player ${player}`;
    document.body.appendChild(message);
    
    setTimeout(() => {
        if (message.parentNode) {
            message.parentNode.removeChild(message);
        }
    }, 1500);
}

function autoSelectAndConfirm() {
    const playerKey = `player${gameState.currentPlayer}`;
    const potentialScores = calculatePotentialScores();
    let availableIndex = -1;
    
    for (let i = 0; i < 6; i++) {
        if (gameState.confirmedCategories[playerKey][i] === null) { 
            availableIndex = i; 
            break; 
        }
    }
    
    if (availableIndex !== -1) {
        gameState.confirmedCategories[playerKey][availableIndex] = 0;
        
        const message = document.createElement('div');
        message.className = 'turn-lost-message';
        message.style.background = 'linear-gradient(135deg, #FF3333, #CC0000)';
        message.textContent = `‚ùå Player ${gameState.currentPlayer} didn't confirm any score! (0 points added)`;
        document.body.appendChild(message);
        
        setTimeout(() => {
            if (message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 2000);
    }
    
    setTimeout(() => {
        checkSpecialBonus();
        checkGameCompletion();
    }, 1000);
}

// ======================================= //
// üé≤ DICE MANAGEMENT & SCORING            //
// ======================================= //

let diceData = [
    { id: 0, locked: false, value: rand1to6() },
    { id: 1, locked: false, value: rand1to6() },
    { id: 2, locked: false, value: rand1to6() },
    { id: 3, locked: false, value: rand1to6() },
    { id: 4, locked: false, value: rand1to6() }
];

let isRolling = false;

function calculatePotentialScores() {
    const scores = Array(6).fill(0);
    for (let category = 1; category <= 6; category++) {
        scores[category-1] = diceData
            .filter(dice => dice.value === category)
            .reduce((sum, dice) => sum + dice.value, 0);
    }
    return scores;
}

// ======================================= //
// üèóÔ∏è RENDER SCORE BOARD - UPDATED          //
// ======================================= //

function renderScoreBoard() {
    const container = document.getElementById('score-board');
    const existingHeader = container.querySelector('.score-header');
    container.innerHTML = '';
    container.appendChild(existingHeader);
    
    for (let i = 1; i <= 6; i++) {
        const row = document.createElement('div');
        row.className = `score-row`;
        row.dataset.category = i-1;
        row.dataset.value = i;

        // Player 1 column
        const col1 = document.createElement('div');
        col1.className = 'score-column';
        
        const input1 = document.createElement('input');
        input1.type = 'text';
        input1.className = 'value-box';
        input1.readOnly = true;
        input1.dataset.player = '1';
        input1.value = '0';
        col1.appendChild(input1);

        // Dice column (middle)
        const colDice = document.createElement('div');
        colDice.className = 'score-column dice';
        
        const img = document.createElement('img');
        img.src = baseURL + i + '.png';
        img.className = 'mini-dice';
        img.alt = `Dice ${i}`;
        img.title = `Click to score category ${i}`;
        colDice.appendChild(img);

        // Player 2 column
        const col2 = document.createElement('div');
        col2.className = 'score-column';
        
        const input2 = document.createElement('input');
        input2.type = 'text';
        input2.className = 'value-box';
        input2.readOnly = true;
        input2.dataset.player = '2';
        input2.value = '0';
        col2.appendChild(input2);

        row.appendChild(col1);
        row.appendChild(colDice);
        row.appendChild(col2);

        // Click event for category selection
        row.addEventListener('click', () => {
            if (gameState.gameFinished) return;
            if (gameState.rollCount === 0) return;
            
            const idx = parseInt(row.dataset.category, 10);
            const playerKey = `player${gameState.currentPlayer}`;
            
            if (gameState.confirmedCategories[playerKey][idx] !== null) {
                row.style.animation = 'shake 0.5s';
                setTimeout(() => row.style.animation = '', 500);
                return;
            }

            document.querySelectorAll('#score-board .score-row.selected').forEach(r => {
                r.classList.remove('selected');
            });
            
            row.classList.add('selected');
            gameState.selectedCategory = { 
                player: gameState.currentPlayer, 
                rowIndex: idx 
            };
            
            selectSound.currentTime = 0;
            selectSound.play();
            
            document.getElementById('play-btn').disabled = false;
        });

        container.appendChild(row);
    }
    updateScoreDisplays();
}

function updateScoreDisplays() {
    if (gameState.gameFinished) return;
    const potential = calculatePotentialScores();

    const rows = document.querySelectorAll('#score-board .score-row');
    rows.forEach((row, index) => {
        const input1 = row.querySelector('.value-box[data-player="1"]');
        const input2 = row.querySelector('.value-box[data-player="2"]');

        const conf1 = gameState.confirmedCategories.player1[index];
        const conf2 = gameState.confirmedCategories.player2[index];

        // Player 1
        if (conf1 !== null) {
            input1.value = conf1;
            input1.classList.add('confirmed','player1');
            input1.classList.remove('locked');
        } else {
            if (gameState.currentPlayer === 1) {
                input1.value = potential[index] || 0;
                input1.classList.remove('confirmed','player1','locked');
            } else {
                input1.value = '‚Äî';
                input1.classList.add('locked');
                input1.classList.remove('confirmed','player1');
            }
        }

        // Player 2
        if (conf2 !== null) {
            input2.value = conf2;
            input2.classList.add('confirmed','player2');
            input2.classList.remove('locked');
        } else {
            if (gameState.currentPlayer === 2) {
                input2.value = potential[index] || 0;
                input2.classList.remove('confirmed','player2','locked');
            } else {
                input2.value = '‚Äî';
                input2.classList.add('locked');
                input2.classList.remove('confirmed','player2');
            }
        }
    });
}

// ======================================= //
// üé≤ RENDER 3D DICE                        //
// ======================================= //

function renderDice() {
    const container = document.getElementById('dice-container');
    container.innerHTML = '';

    diceData.forEach((diceItem) => {
        const scene = document.createElement('div');
        scene.className = 'scene';
        if (diceItem.locked) scene.classList.add('locked');
        scene.dataset.id = diceItem.id;

        const cube = document.createElement('div');
        cube.className = 'cube';
        cube.id = `cube${diceItem.id}`;

        for (let f = 1; f <= 6; f++) {
            const face = document.createElement('div');
            face.className = `face f${f}`;
            const grid = document.createElement('div');
            grid.className = 'grid3';
            grid.dataset.face = f;

            for(let j = 1; j <= 9; j++){
                const slot = document.createElement('div');
                slot.style.display = 'flex';
                slot.style.alignItems = 'center';
                slot.style.justifyContent = 'center';
                if(facePips[f].includes(j)){
                    const pip = document.createElement('div');
                    pip.className = 'pip';
                    slot.appendChild(pip);
                }
                grid.appendChild(slot);
            }
            face.appendChild(grid);
            cube.appendChild(face);
        }

        scene.appendChild(cube);
        container.appendChild(scene);

        const rot = rotations[diceItem.value];
        cube.style.transform = `rotateX(${rot.x}deg) rotateY(${rot.y}deg)`;

        scene.addEventListener('click', () => {
            if (isRolling) return;
            if (gameState.rollCount === 0) return;
            if (gameState.gameFinished) return;

            const idx = diceData.findIndex(d => d.id === diceItem.id);
            if (idx === -1) return;
            
            diceData[idx].locked = !diceData[idx].locked;

            lockSound.currentTime = 0;
            lockSound.play();

            if (diceData[idx].locked) {
                scene.classList.add('locked');
            } else {
                scene.classList.remove('locked');
            }
            
            updateScoreDisplays();
        });
    });
}

// ======================================= //
// üé≤ ROLL SINGLE DICE                      //
// ======================================= //

function rollSingleDice(diceIndex) {
    return new Promise((resolve) => {
        const diceItem = diceData[diceIndex];
        if (diceItem.locked) { resolve(); return; }
        
        const newValue = rand1to6();
        diceItem.value = newValue;
        
        setTimeout(() => {
            diceSound.currentTime = 0;
            diceSound.play().catch(e => console.log("Sound error"));
        }, diceIndex * 100);
        
        const cube = document.getElementById(`cube${diceIndex}`);
        if (!cube) { resolve(); return; }

        const rot = rotations[newValue];
        const extraX = 360 * (2 + Math.floor(Math.random() * 2));
        const extraY = 360 * (2 + Math.floor(Math.random() * 2));

        cube.style.transition = 'transform 1s cubic-bezier(.2,.9,.3,1)';
        cube.style.transform = `rotateX(${rot.x + extraX}deg) rotateY(${rot.y + extraY}deg)`;

        cube.addEventListener('transitionend', function handler(e) {
            if (e.propertyName !== 'transform') return;
            cube.removeEventListener('transitionend', handler);

            cube.style.transition = 'none';
            cube.style.transform = `rotateX(${rot.x}deg) rotateY(${rot.y}deg)`;

            setTimeout(() => {
                cube.style.transition = 'transform 1s cubic-bezier(.2,.9,.3,1)';
                resolve();
            }, 30);
        });
    });
}

// ======================================= //
// üéÆ ROLL BUTTON                           //
// ======================================= //

document.getElementById("roll-btn").addEventListener("click", async () => {
    if (isRolling) return;
    if (gameState.rollCount >= gameState.maxRolls) return;
    if (gameState.gameFinished) return;

    isRolling = true;
    const btn = document.getElementById("roll-btn");
    btn.disabled = true;
    
    gameState.selectedCategory = null;
    document.querySelectorAll('#score-board .score-row.selected').forEach(r => {
        r.classList.remove('selected');
    });
    document.getElementById('play-btn').disabled = true;

    const unlockedIndices = diceData
        .map((d, idx) => !d.locked ? idx : -1)
        .filter(idx => idx !== -1);

    if (unlockedIndices.length > 0) {
        const promises = unlockedIndices.map(idx => rollSingleDice(idx));
        await Promise.all(promises);
    }

    gameState.rollCount++;
    renderDice();
    updateScoreDisplays();

    if (gameState.rollCount >= gameState.maxRolls) {
        btn.disabled = true;
        btn.textContent = "3 rolls used";
    } else {
        btn.disabled = false;
        btn.textContent = `Roll Dice (${3 - gameState.rollCount} left)`;
    }

    isRolling = false;
});

// ======================================= //
// üéÆ PLAY BUTTON (CONFIRM SCORE)           //
// ======================================= //

document.getElementById("play-btn").addEventListener("click", function() {
    if (!gameState.selectedCategory) return;
    if (gameState.gameFinished) return;

    const { player, rowIndex } = gameState.selectedCategory;
    const playerKey = `player${player}`;
    const potentialScores = calculatePotentialScores();
    const score = potentialScores[rowIndex];

    gameState.confirmedCategories[playerKey][rowIndex] = score;
    
    // Animation effect for confirmed score
    const selectedRow = document.querySelector('#score-board .score-row.selected');
    if (selectedRow) {
        const valueBox = selectedRow.querySelector(`.value-box[data-player="${player}"]`);
        if (valueBox) {
            valueBox.style.animation = 'scorePop 0.5s';
            setTimeout(() => valueBox.style.animation = '', 500);
        }
    }
    
    confirmSound.currentTime = 0;
    confirmSound.play();
    
    gameState.selectedCategory = null;
    document.querySelectorAll('#score-board .score-row.selected').forEach(r => {
        r.classList.remove('selected');
    });
    
    this.disabled = true;
    checkSpecialBonus();
    checkGameCompletion();
});

// ======================================= //
// üîÑ TURN MANAGEMENT                       //
// ======================================= //

function resetDiceForNewTurn() {
    diceData.forEach(d => d.locked = false);
    diceData = [
        { id: 0, locked: false, value: rand1to6() },
        { id: 1, locked: false, value: rand1to6() },
        { id: 2, locked: false, value: rand1to6() },
        { id: 3, locked: false, value: rand1to6() },
        { id: 4, locked: false, value: rand1to6() }
    ];
    gameState.rollCount = 0;
    gameState.selectedCategory = null;
}

function nextTurn() {
    resetDiceForNewTurn();
    gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
    updateTurnDisplay();
    renderDice();
    document.getElementById("play-btn").disabled = true;
    document.getElementById("roll-btn").disabled = false;
    document.getElementById("roll-btn").textContent = "Roll Dice";
    if (!gameState.gameFinished) startTimer();
    updateScoreDisplays();
}

function checkSpecialBonus() {
    const values = diceData.map(d=>d.value);
    const counts = {};
    values.forEach(v => counts[v] = (counts[v] || 0) + 1);
    for (const v in counts) if (counts[v] === 5) {
        const key = `player${gameState.currentPlayer}`;
        gameState.specialBonuses[key]++;
        break;
    }
}

function checkGameCompletion() {
    const p1filled = gameState.confirmedCategories.player1.every(x=>x!==null);
    const p2filled = gameState.confirmedCategories.player2.every(x=>x!==null);
    if (p1filled && p2filled) endGame();
    else nextTurn();
}

function endGame() {
    gameState.gameFinished = true;
    clearInterval(timerInterval);
    const results = calculateFinalResults();
    updateGameStats(results);
    showResultsScreen(results);
    document.getElementById('main-box').style.display = 'none';
    document.getElementById('score-board').style.display = 'none';
    document.getElementById('top-wrapper').style.display = 'none';
}

// ======================================= //
// üèÜ FINAL RESULTS CALCULATION             //
// ======================================= //

function calculateFinalResults() {
    const player1BaseScore = gameState.confirmedCategories.player1.reduce((s, v) => s + (v||0), 0);
    const player2BaseScore = gameState.confirmedCategories.player2.reduce((s, v) => s + (v||0), 0);
    const player1SpecialBonus = calculateSpecialBonus(gameState.specialBonuses.player1);
    const player2SpecialBonus = calculateSpecialBonus(gameState.specialBonuses.player2);
    const player1Total = player1BaseScore + player1SpecialBonus;
    const player2Total = player2BaseScore + player2SpecialBonus;
    let winner = null;
    if (player1Total > player2Total) winner = 1;
    else if (player2Total > player1Total) winner = 2;
    return {
        player1: { 
            baseScore: player1BaseScore, 
            specialBonus: player1SpecialBonus, 
            totalScore: player1Total, 
            specialCount: gameState.specialBonuses.player1 
        },
        player2: { 
            baseScore: player2BaseScore, 
            specialBonus: player2SpecialBonus, 
            totalScore: player2Total, 
            specialCount: gameState.specialBonuses.player2 
        },
        winner
    };
}

function calculateSpecialBonus(count) {
    if (count === 0) return 0;
    if (count === 1) return 50;
    if (count === 2) return 100;
    if (count >= 3) return 300;
    return 0;
}

function updateGameStats(results) {
    gameStats.player1.gamesPlayed++;
    gameStats.player2.gamesPlayed++;
    gameStats.player1.totalScore += results.player1.totalScore;
    gameStats.player2.totalScore += results.player2.totalScore;
    gameStats.player1.totalSpecialBonus += results.player1.specialBonus;
    gameStats.player2.totalSpecialBonus += results.player2.specialBonus;
    if (results.winner === 1) { 
        gameStats.player1.wins++; 
        gameStats.player2.losses++; 
    }
    else if (results.winner === 2) { 
        gameStats.player2.wins++; 
        gameStats.player1.losses++; 
    }
}

// ======================================= //
// üìä RESULTS SCREEN                        //
// ======================================= //

function showResultsScreen(results) {
    const resultsScreen = document.getElementById('results-screen');
    const resultsColumns = document.getElementById('resultsColumns');
    resultsColumns.innerHTML = '';
    
    for (let playerNum = 1; playerNum <= 2; playerNum++) {
        const playerKey = `player${playerNum}`;
        const playerData = results[playerKey];
        const playerStats = gameStats[playerKey];
        
        const playerDiv = document.createElement('div');
        
        playerDiv.style.background = playerNum === 1 
            ? 'linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.1))'
            : 'linear-gradient(135deg, rgba(0, 255, 127, 0.15), rgba(0, 204, 102, 0.1))';
        playerDiv.style.padding = '12px';
        playerDiv.style.borderRadius = '8px';
        playerDiv.style.marginBottom = '12px';
        playerDiv.style.border = '2px solid ' + (playerNum === 1 ? 'rgba(255, 215, 0, 0.4)' : 'rgba(0, 255, 127, 0.4)');
        
        if (results.winner === playerNum) {
            playerDiv.style.boxShadow = '0 0 25px rgba(255, 215, 0, 0.6)';
            playerDiv.style.borderColor = playerNum === 1 ? '#FFD700' : '#00FF7F';
        }
        
        playerDiv.innerHTML = `
            <div style="font-size: 18px; font-weight: bold; margin-bottom: 10px; color: ${playerNum === 1 ? '#FFD700' : '#00FF7F'}">
                ${playerNum === 1 ? 'üëë' : '‚öîÔ∏è'} ${gameState.playerNames[playerKey]} ${results.winner === playerNum ? 'üèÜ Winner!' : ''}
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between;">
                <div style="flex: 1; min-width: 120px;">
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="font-size: 14px;">Score:</span>
                            <span style="font-weight: bold; font-size: 18px;">${playerData.totalScore}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="font-size: 12px; color: #aaa;">Base:</span>
                            <span style="font-size: 14px;">${playerData.baseScore}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="font-size: 12px; color: #aaa;">Special:</span>
                            <span style="font-size: 14px; color: #4eff4e;">${playerData.specialBonus}</span>
                        </div>
                    </div>
                </div>
                <div style="flex: 1; min-width: 120px;">
                    <div style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="font-size: 12px; color: #aaa;">Games:</span>
                            <span style="font-size: 14px;">${playerStats.gamesPlayed}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span style="font-size: 12px; color: #aaa;">Wins:</span>
                            <span style="font-size: 14px; color: #4eff4e;">${playerStats.wins}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span style="font-size: 12px; color: #aaa;">Losses:</span>
                            <span style="font-size: 14px; color: #ff3333;">${playerStats.losses}</span>
                        </div>
                    </div>
                </div>
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #aaa; text-align: center;">
                Room: ${gameState.roomId || 'Local Game'} | Cooldown: 10 minutes
            </div>
        `;
        
        resultsColumns.appendChild(playerDiv);
    }
    resultsScreen.style.display = 'block';
}

// ======================================= //
// üîÑ TURN DISPLAY UPDATE                   //
// ======================================= //

function updateTurnDisplay() {
    const left = document.getElementById('playerBox1');
    const right = document.getElementById('playerBox2');
    
    if (gameState.currentPlayer === 1) {
        left.classList.remove('inactive');
        left.classList.add('active-player');
        right.classList.remove('active-player');
        right.classList.add('inactive');
    } else {
        right.classList.remove('inactive');
        right.classList.add('active-player');
        left.classList.remove('active-player');
        left.classList.add('inactive');
    }
    
    updateTimerDisplay();
}

// ======================================= //
// üöÄ GAME INITIALIZATION                  //
// ======================================= //

window.addEventListener('DOMContentLoaded', () => {
    // Check for room token in URL
    const urlParams = new URLSearchParams(window.location.search);
    const roomToken = urlParams.get('room');
    const gameToken = urlParams.get('token');
    
    // Show appropriate message based on access method
    if (!roomToken && !gameToken) {
        // Direct access - show instruction
        document.body.innerHTML = `
            <div style="text-align: center; padding: 50px; color: white;">
                <h1>üé≤ Dice Party</h1>
                <p>Please join this game through the Telegram bot.</p>
                <p>The bot will provide you with a game link.</p>
                <p style="margin-top: 30px; color: #aaa;">Game features:</p>
                <ul style="list-style: none; padding: 0;">
                    <li>‚úÖ 30-second timer per turn</li>
                    <li>‚úÖ 3 dice rolls maximum</li>
                    <li>‚úÖ Special bonus for 5-of-a-kind</li>
                    <li>‚úÖ 10-minute cooldown between games</li>
                    <li>‚úÖ Room system with spectators</li>
                </ul>
            </div>
        `;
        return;
    }
    
    // Initialize game if token is present
    renderScoreBoard();
    renderDice();
    updateTurnDisplay();
    startTimer();
    
    // Store token for API calls
    if (gameToken) {
        localStorage.setItem('dice_game_token', gameToken);
    }
    if (roomToken) {
        gameState.roomId = roomToken;
    }
});

// ======================================= //
// üîê API INTEGRATION FUNCTIONS            //
// ======================================= //

// API Helper functions - Will be fully implemented with Edge Functions
const DiceAPI = {
    async validateToken(token) {
        try {
            const response = await fetch(`${SUPABASE_CONFIG.FUNCTIONS_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_CONFIG.ANON_KEY}`
                },
                body: JSON.stringify({
                    action: 'VALIDATE_TOKEN',
                    token: token
                })
            });
            return await response.json();
        } catch (error) {
            console.error('Token validation error:', error);
            return { success: false, error: 'Connection failed' };
        }
    },
    
    async createRoom(token, gameType = 'single') {
        try {
            const response = await fetch(`${SUPABASE_CONFIG.FUNCTIONS_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_CONFIG.ANON_KEY}`
                },
                body: JSON.stringify({
                    action: 'CREATE_ROOM',
                    token: token,
                    game_type: gameType
                })
            });
            return await response.json();
        } catch (error) {
            console.error('Create room error:', error);
            return { success: false, error: 'Connection failed' };
        }
    },
    
    async rollDice(token, roomId, playerId, lockedIndices = []) {
        try {
            const response = await fetch(`${SUPABASE_CONFIG.FUNCTIONS_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_CONFIG.ANON_KEY}`
                },
                body: JSON.stringify({
                    action: 'ROLL_DICE',
                    token: token,
                    room_id: roomId,
                    player_id: playerId,
                    locked_indices: lockedIndices
                })
            });
            return await response.json();
        } catch (error) {
            console.error('Roll dice error:', error);
            return { success: false, error: 'Connection failed' };
        }
    },
    
    async confirmScore(token, roomId, playerId, categoryIndex) {
        try {
            const response = await fetch(`${SUPABASE_CONFIG.FUNCTIONS_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_CONFIG.ANON_KEY}`
                },
                body: JSON.stringify({
                    action: 'CONFIRM_SCORE',
                    token: token,
                    room_id: roomId,
                    player_id: playerId,
                    category_index: categoryIndex
                })
            });
            return await response.json();
        } catch (error) {
            console.error('Confirm score error:', error);
            return { success: false, error: 'Connection failed' };
        }
    },
    
    async getRoomStatus(roomId) {
        try {
            const response = await fetch(`${SUPABASE_CONFIG.FUNCTIONS_URL}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SUPABASE_CONFIG.ANON_KEY}`
                },
                body: JSON.stringify({
                    action: 'GET_ROOM_STATUS',
                    room_id: roomId
                })
            });
            return await response.json();
        } catch (error) {
            console.error('Get room status error:', error);
            return { success: false, error: 'Connection failed' };
        }
    }
};

// Test function for debugging
window.testCreateRoom = async function() {
    const token = localStorage.getItem('dice_game_token') || 'test-token';
    const result = await DiceAPI.createRoom(token, 'single');
    console.log('Test create room result:', result);
    if (result.success) {
        alert(`Room created: ${result.data.room_id}`);
        gameState.roomId = result.data.room_id;
    }
};
</script>
</body>
</html>
